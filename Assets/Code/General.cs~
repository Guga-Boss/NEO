using UnityEngine;
using System.Collections;

public class Util
{
	public Vector2[] DirCord;
	public int[] InvDir;

	public Util()
	{
		DirCord	= new Vector2[] { new Vector2(0, 1),  new Vector2( 1, 1),   new Vector2( 1, 0),   new Vector2( 1,-1),  
		  	                      new Vector2(0,-1),  new Vector2(-1,-1),   new Vector2(-1, 0),   new Vector2(-1, 1)};
		InvDir = new int[] { 4, 5, 6, 7, 0, 1, 2, 3 };
		
	}

	public static GameObject FObj( string name )
	{
		GameObject obj = GameObject.Find ( name );		
		if( obj == null ) Debug.LogError("Object Not Found: " + name );
		return obj;
	}

	/*public 	void Lim( out float num, float min, float max )
	{
		if( num < min ) num = min;
		if( num > max ) num = max;
	}
	
	public 	void Lim( out int num, int min, int max )
	{
		if( num < min ) num = min;
		if( num > max ) num = max;
	}*/
	public 	static float Percent(float percent , float num)
	{
		return percent * num / 100;
	}
	public 	int Mod( int i )
	{
		if( i < 0 ) i *= -1;
		return i;
	}	
	public 	float Mod( float i )
	{
		if( i < 0 ) i *= -1;
		return i;
	}
	public static void SetLayerRecursively(GameObject go, int layerNumber) {
		if (go == null) return;
		foreach (Transform trans in go.GetComponentsInChildren<Transform>(true)) {
			trans.gameObject.layer = layerNumber;
		}
	}
}

[System.Serializable]
public class Timer {
	
	public float Target, Elapsed, Remaining;
	public bool bActive;
	public Timer() {}
	public void Reset() { Target = Elapsed = Remaining = 0; bActive = false; }
	
	public void Start( float target ) {
		Reset ();
		bActive = true; 
		Target = target;
		Remaining = target;
	} 
	
	public bool Done() {
		if( Elapsed >= Target ) return true; 
		return false;
	}

	public bool Update() {
		if( bActive )
		{
			Elapsed += Time.deltaTime;
			Remaining -= Time.deltaTime;
			if( Elapsed >= Target ) { return true; }
		}
		return false;
	}
}


[System.Serializable]
public struct Vector
{
	//
	// Static Fields
	//
	public const float kEpsilon = 1E-05f;
	
	//
	// Fields
	//
	public int y;	
	public int x;
	
	//
	// Static Properties
	//
/*	public static Vector back
	{
		get
		{
			return new Vector (0f, 0f, -1f);
		}
	}
	
	public static Vector down
	{
		get
		{
			return new Vector (0f, -1f, 0f);
		}
	}
	
	public static Vector forward
	{
		get
		{
			return new Vector (0f, 0f, 1f);
		}
	}
	
	[Obsolete ("Use Vector.forward instead.")]
	public static Vector fwd
	{
		get
		{
			return new Vector (0f, 0f, 1f);
		}
	}
	
	public static Vector left
	{
		get
		{
			return new Vector (-1f, 0f, 0f);
		}
	}
	
	public static Vector one
	{
		get
		{
			return new Vector (1f, 1f, 1f);
		}
	}
	
	public static Vector right
	{
		get
		{
			return new Vector (1f, 0f, 0f);
		}
	}
	
	public static Vector up
	{
		get
		{
			return new Vector (0f, 1f, 0f);
		}
	}
	
	public static Vector zero
	{
		get
		{
			return new Vector (0f, 0f, 0f);
		}
	}
	
	//
	// Properties
	//
	public float magnitude
	{
		get
		{
			return Mathf.Sqrt (this.x * this.x + this.y * this.y + this.z * this.z);
		}
	}
	
	public Vector normalized
	{
		get
		{
			return Vector.Normalize (this);
		}
	}
	
	public float sqrMagnitude
	{
		get
		{
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}
	}
	
	//
	// Indexer
	//
	public float this [int index]
	{
		get
		{
			switch (index)
			{
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw new IndexOutOfRangeException ("Invalid Vector index!");
			}
		}
		set
		{
			switch (index)
			{
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			default:
				throw new IndexOutOfRangeException ("Invalid Vector index!");
			}
		}
	}*/
	
	//
	// Constructors
	//
	public Vector (int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public string GetStr()
	{
		string str = " ( " + x + ", " + y + " ) ";
		return str;
	}

	/*
	//
	// Static Methods
	//
	public static float Angle (Vector from, Vector to)
	{
		return Mathf.Acos (Mathf.Clamp (Vector.Dot (from.normalized, to.normalized), -1f, 1f)) * 57.29578f;
	}
	
	[Obsolete ("Use Vector.Angle instead. AngleBetween uses radians instead of degrees and was deprecated for this reason")]
	public static float AngleBetween (Vector from, Vector to)
	{
		return Mathf.Acos (Mathf.Clamp (Vector.Dot (from.normalized, to.normalized), -1f, 1f));
	}
	
	public static Vector ClampMagnitude (Vector vector, float maxLength)
	{
		if (vector.sqrMagnitude > maxLength * maxLength)
		{
			return vector.normalized * maxLength;
		}
		return vector;
	}
	
	public static Vector Cross (Vector lhs, Vector rhs)
	{
		return new Vector (lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);
	}
	
	public static float Distance (Vector a, Vector b)
	{
		Vector vector = new Vector (a.x - b.x, a.y - b.y, a.z - b.z);
		return Mathf.Sqrt (vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
	}
	
	public static float Dot (Vector lhs, Vector rhs)
	{
		return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
	}
	
	public static Vector Exclude (Vector excludeThis, Vector fromThat)
	{
		return fromThat - Vector.Project (fromThat, excludeThis);
	}
	
	public static Vector Lerp (Vector from, Vector to, float t)
	{
		t = Mathf.Clamp01 (t);
		return new Vector (from.x + (to.x - from.x) * t, from.y + (to.y - from.y) * t, from.z + (to.z - from.z) * t);
	}
	
	public static float Magnitude (Vector a)
	{
		return Mathf.Sqrt (a.x * a.x + a.y * a.y + a.z * a.z);
	}
	
	public static Vector Max (Vector lhs, Vector rhs)
	{
		return new Vector (Mathf.Max (lhs.x, rhs.x), Mathf.Max (lhs.y, rhs.y), Mathf.Max (lhs.z, rhs.z));
	}
	
	public static Vector Min (Vector lhs, Vector rhs)
	{
		return new Vector (Mathf.Min (lhs.x, rhs.x), Mathf.Min (lhs.y, rhs.y), Mathf.Min (lhs.z, rhs.z));
	}
	
	public static Vector MoveTowards (Vector current, Vector target, float maxDistanceDelta)
	{
		Vector a = target - current;
		float magnitude = a.magnitude;
		if (magnitude <= maxDistanceDelta || magnitude == 0f)
		{
			return target;
		}
		return current + a / magnitude * maxDistanceDelta;
	}
	
	public static Vector Normalize (Vector value)
	{
		float num = Vector.Magnitude (value);
		if (num > 1E-05f)
		{
			return value / num;
		}
		return Vector.zero;
	}
	
	public static void OrthoNormalize (ref Vector normal, ref Vector tangent, ref Vector binormal)
	{
		Vector.Internal_OrthoNormalize3 (ref normal, ref tangent, ref binormal);
	}
	
	public static void OrthoNormalize (ref Vector normal, ref Vector tangent)
	{
		Vector.Internal_OrthoNormalize2 (ref normal, ref tangent);
	}
	
	public static Vector Project (Vector vector, Vector onNormal)
	{
		float num = Vector.Dot (onNormal, onNormal);
		if (num < 1.401298E-45f)
		{
			return Vector.zero;
		}
		return onNormal * Vector.Dot (vector, onNormal) / num;
	}
	
	public static Vector Reflect (Vector inDirection, Vector inNormal)
	{
		return -2f * Vector.Dot (inNormal, inDirection) * inNormal + inDirection;
	}
	
	public static Vector RotateTowards (Vector current, Vector target, float maxRadiansDelta, float maxMagnitudeDelta)
	{
		return Vector.INTERNAL_CALL_RotateTowards (ref current, ref target, maxRadiansDelta, maxMagnitudeDelta);
	}
	
	public static Vector Scale (Vector a, Vector b)
	{
		return new Vector (a.x * b.x, a.y * b.y, a.z * b.z);
	}
	
	public static Vector Slerp (Vector from, Vector to, float t)
	{
		return Vector.INTERNAL_CALL_Slerp (ref from, ref to, t);
	}
	
	[ExcludeFromDocs]
	public static Vector SmoothDamp (Vector current, Vector target, ref Vector currentVelocity, float smoothTime)
	{
		float deltaTime = Time.deltaTime;
		float maxSpeed = float.PositiveInfinity;
		return Vector.SmoothDamp (current, target, ref currentVelocity, smoothTime, maxSpeed, deltaTime);
	}
	
	public static Vector SmoothDamp (Vector current, Vector target, ref Vector currentVelocity, float smoothTime, [DefaultValue ("Mathf.Infinity")] float maxSpeed, [DefaultValue ("Time.deltaTime")] float deltaTime)
	{
		smoothTime = Mathf.Max (0.0001f, smoothTime);
		float num = 2f / smoothTime;
		float num2 = num * deltaTime;
		float d = 1f / (1f + num2 + 0.48f * num2 * num2 + 0.235f * num2 * num2 * num2);
		Vector vector = current - target;
		Vector vector2 = target;
		float maxLength = maxSpeed * smoothTime;
		vector = Vector.ClampMagnitude (vector, maxLength);
		target = current - vector;
		Vector Vector = (currentVelocity + num * vector) * deltaTime;
		currentVelocity = (currentVelocity - num * Vector) * d;
		Vector vector4 = target + (vector + Vector) * d;
		if (Vector.Dot (vector2 - current, vector4 - vector2) > 0f)
		{
			vector4 = vector2;
			currentVelocity = (vector4 - vector2) / deltaTime;
		}
		return vector4;
	}
	
	[ExcludeFromDocs]
	public static Vector SmoothDamp (Vector current, Vector target, ref Vector currentVelocity, float smoothTime, float maxSpeed)
	{
		float deltaTime = Time.deltaTime;
		return Vector.SmoothDamp (current, target, ref currentVelocity, smoothTime, maxSpeed, deltaTime);
	}*/
	
	public static float SqrMagnitude (Vector a)
	{
		return a.x * a.x + a.y * a.y;
	}
	/*
	//
	// Methods
	/// <summary>
	/// Determines whether the specified <see cref="System.Object"/> is equal to the current <see cref="Vector"/>.
	/// </summary>
	/// <param name="other">The <see cref="System.Object"/> to compare with the current <see cref="Vector"/>.</param>
	/// <returns><c>true</c> if the specified <see cref="System.Object"/> is equal to the current <see cref="Vector"/>; otherwise, <c>false</c>.</returns>
	public override bool Equals (object other)
	{
		if (!(other is Vector))
		{
			return false;
		}
		Vector vector = (Vector)other;
		return this.x.Equals (vector.x) && this.y.Equals (vector.y) && this.z.Equals (vector.z);
	}
	
	public override int GetHashCode ()
	{
		return this.x.GetHashCode () ^ this.y.GetHashCode () << 2 ^ this.z.GetHashCode () >> 2;
	}
	
	public void Normalize ()
	{
		float num = Vector.Magnitude (this);
		if (num > 1E-05f)
		{
			this /= num;
		}
		else
		{
			this = Vector.zero;
		}
	}
	
	public void Scale (Vector scale)
	{
		this.x *= scale.x;
		this.y *= scale.y;
		this.z *= scale.z;
	}
	
	public void Set (float new_x, float new_y, float new_z)
	{
		this.x = new_x;
		this.y = new_y;
		this.z = new_z;
	}
	
	public string ToString (string format)
	{
		return UnityString.Format ("({0}, {1}, {2})", new object[]
		                           {
			this.x.ToString (format),
			this.y.ToString (format),
			this.z.ToString (format)
		});
	}
	
	public override string ToString ()
	{
		return UnityString.Format ("({0:F1}, {1:F1}, {2:F1})", new object[]
		                           {
			this.x,
			this.y,
			this.z
		});
	}*/

	public Vector2 ToVector2()
	{
		return new Vector2( x, y );
	}

	//
	// Operators
	//
	public static Vector operator + (Vector a, Vector b)
	{
		return new Vector (a.x + b.x, a.y + b.y);
	}
	
	public static Vector operator / (Vector a, int d)
	{
		return new Vector (a.x / d, a.y / d);
	}
	
	public static bool operator == (Vector lhs, Vector rhs)
	{
		return Vector.SqrMagnitude (lhs - rhs) < 9.99999944E-11f;
	}
	
	public static bool operator != (Vector lhs, Vector rhs)
	{
		return Vector.SqrMagnitude (lhs - rhs) >= 9.99999944E-11f;
	}
	
	public static Vector operator * (Vector a, int d)
	{
		return new Vector (a.x * d, a.y * d);
	}
	
	public static Vector operator * (int d, Vector a)
	{
		return new Vector (a.x * d, a.y * d);
	}
	
	public static Vector operator - (Vector a, Vector b)
	{
		return new Vector (a.x - b.x, a.y - b.y);
	}
	
	public static Vector operator - (Vector a)
	{
		return new Vector (-a.x, -a.y);
	}
}

